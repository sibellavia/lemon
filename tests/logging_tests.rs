use anyhow::{Context, Result};
use lemon::{config, logging};
use serde_json::Value;
use tempfile::tempdir;
use tokio::fs;
use tokio::time::{Duration, sleep};
use tracing::{debug, info, warn};

#[tokio::test]
async fn test_logging_to_file_json() -> Result<()> {
    // 1. Setup: Temp dir, log file path
    let temp_dir = tempdir().context("Failed to create temp dir")?;
    let log_path = temp_dir.path().join("test_log.log");
    let config_path = temp_dir.path().join("lemon.toml");

    // 2. Config Content: Log DEBUG to file in JSON format
    let config_content = format!(
        r#"
[logging]
level = "debug"
format = "json"
output = {{ type = "file", path = "{}" }}

# No server block needed if we don't run squeeze
"#,
        log_path.display()
    );
    fs::write(&config_path, config_content)
        .await
        .context("Failed to write temp config")?;

    // 3. Load config and setup logging directly
    let loaded_config = config::load_and_validate_config(config_path.to_str().unwrap()).await?;
    let guards = logging::setup_logging(loaded_config.logging.as_ref())?;

    // 4. Generate some logs
    info!(test_event = true, "This is an INFO message for the test.");
    debug!(test_event = true, "This is a DEBUG message for the test.");
    warn!(test_event = true, "This is a WARN message.");
    // A trace message (should be filtered out by level = "debug")
    tracing::trace!(test_event = true, "This TRACE message should not appear.");

    // 5. Drop guards to flush logs and wait briefly
    drop(guards);
    sleep(Duration::from_millis(100)).await; // Give time for flush

    // 6. Read Log File
    let log_content = fs::read_to_string(&log_path)
        .await
        .context(format!("Failed to read log file at {:?}", log_path))?;

    println!("--- Log Content ---\n{}\n-------------------", log_content);

    // 7. Parse and Assert
    let lines: Vec<&str> = log_content
        .lines()
        .filter(|line| !line.is_empty())
        .collect();
    assert!(!lines.is_empty(), "Log file is empty");

    let mut info_found = false;
    let mut debug_found = false;
    let mut warn_found = false;
    let mut trace_found = false;
    let mut parsed_entries = 0;

    for line in lines {
        let entry: Value = serde_json::from_str(line)
            .with_context(|| format!("Failed to parse log line as JSON: {}", line))?;
        parsed_entries += 1;

        // Only check logs generated by this test
        if !entry["fields"]["test_event"].as_bool().unwrap_or(false) {
            continue;
        }

        let level = entry["level"].as_str().unwrap_or("");
        let message = entry["fields"]["message"].as_str().unwrap_or("");

        match level {
            "INFO" => {
                info_found = true;
                assert!(message.contains("INFO message"));
            }
            "DEBUG" => {
                debug_found = true;
                assert!(message.contains("DEBUG message"));
            }
            "WARN" => {
                warn_found = true;
                assert!(message.contains("WARN message"));
            }
            "TRACE" => {
                trace_found = true; // This flag should remain false
            }
            _ => {}
        }
    }

    assert!(
        parsed_entries >= 3,
        "Expected at least 3 test log entries, found {}",
        parsed_entries
    );
    assert!(info_found, "Test INFO log entry not found");
    assert!(debug_found, "Test DEBUG log entry not found");
    assert!(warn_found, "Test WARN log entry not found");
    assert!(
        !trace_found,
        "TRACE log entry was found but should have been filtered out"
    );

    Ok(())
}
